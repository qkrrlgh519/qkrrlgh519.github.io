---
layout: post
title: "BOJ[12886] - 돌 그룹 by JavaScript"
date: 2021-11-02 12:00:00 +0900
categories: BOJ(BFS)
---

# 돌 그룹

## 문제

- [백준 12886번 - 돌 그룹](https://www.acmicpc.net/problem/12886)

## 언어

- JavaScript

## 순서도

1. BFS 탐색

## 문제 풀이 step 1

- 오늘 강호는 돌을 이용해 재미있는 게임을 하려고 합니다.
- 돌은 세 개의 그룹으로 나누어져 있으며 각각의 그룹에는 돌이 A, B, C 개가 있습니다.
- 강호는 모든 그룹에 있는 돌의 개수를 같게 만들려고 합니다.
- 강호는 돌을 단계별로 움직이며, 각 단계는 다음과 같이 이루어져 있습니다.
  - 크기가 같지 않은 두 그룹을 고릅니다.
  - 그 다음, 돌의 개수가 작은 쪽을 X, 큰 쪽을 Y 라고 정합니다.
  - 그 다음, X 에 있는 돌의 개수를 X + X 개로, Y 에 있는 돌의 개수를 Y - X 개로 만듭니다.
- A, B, C 가 주어졌을 때, 강호가 돌을 같은 개수로 만들 수 있으면 1 을, 아니면 0 을 출력하는 문제입니다.

## 문제 풀이 step 2

- 3 차원 공간에 시작점 (a, b, c) 를 하나의 노드로 생각합니다.
- 그리고 돌을 움직이는 규칙에 따라서 BFS 탐색을 합니다.
  - 탐색을 할 때 방문 처리를 해야하는데, 3 차원 배열을 생성하면 메모리 초과가 발생합니다.
  - 따라서 Map 을 이용해서 방문 처리를 하고, (a, b, c) 를 적절히 문자열로 변환 후 key 값으로 사용합니다.
- BFS 탐색을 모두 마치면 세 개의 돌이 같아지는 순간이 있는 지 검사하고, 있다면 1 을, 없다면 0 을 출력합니다.
- 추가 설명은 주석으로 작성하겠습니다.

## 후기

- 꼭 다시 풀어볼 문제입니다.
- 개선해야 할 점
  - 세 개의 돌그룹의 합이 변하지 않기 때문에 그로 인한 추가 고려점
    - 세 개를 다 더해서 3 으로 나눌 수 있는 지 검사
    - 각 돌그룹을 구분할 필요가 없기 때문에 정렬해서 해도 상관이 없다는 점
    - 두 개의 돌의 개수만 세도 상관 없다는 점

## 소스 코드

```javascript
const input = require("fs")
	.readFileSync("/dev/stdin")
	.toString()
	.trim()
	.split("\n");

class Queue {
	constructor() {
		this.bucket = [];
		this.front = -1;
		this.rear = -1;
	}

	enqueue(item) {
		this.bucket[++this.rear] = item;
	}

	dequeue() {
		return this.bucket[++this.front];
	}

	isEmpty() {
		return this.front === this.rear;
	}
}

const bfs = (a, b, c) => {
	const queue = new Queue();
	// Map 을 이용해서 방문처리
	const visitedMap = new Map();

	if (a === b && b === c) return true;

	queue.enqueue([a, b, c]);
	visitedMap.set([a, b, c].join(" "), true);

	while (!queue.isEmpty()) {
		const [x, y, z] = queue.dequeue();
		const next = [];

		// 규칙에 맞게 다음 탐색 노드 결정
		if (x !== y) {
			if (x < y) {
				next.push([x + x, y - x, z]);
			} else {
				next.push([x - y, y + y, z]);
			}
		}

		if (x !== z) {
			if (x < z) {
				next.push([x + x, y, z - x]);
			} else {
				next.push([x - z, y, z + z]);
			}
		}

		if (y !== z) {
			if (y < z) {
				next.push([x, y + y, z - y]);
			} else {
				next.push([x, y - z, z + z]);
			}
		}

		for (let i = 0; i < next.length; i++) {
			const [nx, ny, nz] = next[i];
			const key = next[i].join(" ");

			// 이미 방문 했다면 SKIP
			if (visitedMap.get(key) === true) continue;
			if (nx === ny && ny === nz) return true;

			// 방문 처리
			visitedMap.set(key, true);
			queue.enqueue([nx, ny, nz]);
		}
	}

	return false;
};

const solution = (input) => {
	const [a, b, c] = input[0].split(" ").map(Number);

	const result = bfs(a, b, c);

	if (result === true) return 1;
	return 0;
};

console.log(solution(input));
```
